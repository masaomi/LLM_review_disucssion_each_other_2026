{
  "task_id": "code_generation_002",
  "models": {
    "opus_4_5": {
      "task_id": "code_generation_002",
      "model_key": "opus_4_5",
      "model_id": "anthropic/claude-opus-4.5",
      "response": "# Bug Analysis and Fix for `find_pairs` Function\n\n## 1. Identifying ALL Bugs and Edge Cases\n\n### Bugs in the Original Code:\n\n1. **Duplicate Handling Issue**: When there are duplicate numbers (e.g., `[3,3,3]` with target `6`), the function only finds some pairs because `seen[nums[i]] = i` overwrites previous occurrences.\n\n2. **Self-Pairing Issue**: A single number cannot pair with itself (e.g., `[4]` with target `8` should return `[]`), but if the same value appears twice, they should pair. The current logic actually handles this correctly by checking `seen` before adding the current number.\n\n3. **Duplicate Pairs Not Fully Captured**: With `[3,3,3]` and target `6`, we should get 3 pairs: `(3,3)`, `(3,3)`, `(3,3)` (indices 0-1, 0-2, 1-2), but the current code only gets 2.\n\n4. **Missing Count Tracking**: The `seen` dictionary stores only the last index, not counts or all indices, losing information about duplicates.\n\n### Edge Cases the Function Fails On:\n\n| Input | Target | Expected | Actual | Issue |\n|-------|--------|----------|--------|-------|\n| `[3,3,3]` | `6` | 3 pairs | 2 pairs | Loses duplicate info |\n| `[1,1,1,1]` | `2` | 6 pairs | 3 pairs | Same issue |\n| `[]` | `5` | `[]` | `[]` | ✓ Works |\n| `[4]` | `8` | `[]` | `[]` | ✓ Works |\n| `[-1,2,-3,4]` | `1` | `[(-1,2), (-3,4)]` | `[(-1,2), (-3,4)]` | ✓ Works |\n\n## 2. Corrected Version\n\n```python\ndef find_pairs(nums, target):\n    \"\"\"\n    Find all pairs of numbers in a list that sum to a target value.\n    \n    Args:\n        nums: List of numbers (can include duplicates and negatives)\n        target: Target sum value\n        \n    Returns:\n        List of tuples, where each tuple is a pair that sums to target.\n        Each pair uses distinct indices (no self-pairing with same element).\n        Pairs are returned in order of discovery.\n    \"\"\"\n    # Handle edge case: empty list or single element\n    if len(nums) < 2:\n        return []\n    \n    pairs = []\n    # Store list of indices for each number to handle duplicates\n    seen = {}  # {number: [list of indices]}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        # Check if complement exists in previously seen numbers\n        if complement in seen:\n            # Create a pair with each occurrence of the complement\n            for j in seen[complement]:\n                pairs.append((complement, num))\n        \n        # Add current number's index to seen\n        if num in seen:\n            seen[num].append(i)\n        else:\n            seen[num] = [i]\n    \n    return pairs\n\n\ndef find_pairs_unique(nums, target):\n    \"\"\"\n    Alternative: Find unique pairs (by value, not index) that sum to target.\n    \n    Returns each unique value pair only once.\n    \"\"\"\n    if len(nums) < 2:\n        return []\n    \n    pairs = []\n    seen = set()\n    used_in_pair = set()\n    \n    for num in nums:\n        complement = target - num\n        \n        if complement in seen:\n            # Create ordered pair to avoid duplicates like (2,3) and (3,2)\n            pair = tuple(sorted([complement, num]))\n            if pair not in used_in_pair:\n                pairs.append((complement, num))\n                used_in_pair.add(pair)\n        \n        seen.add(num)\n    \n    return pairs\n\n\ndef find_pairs_with_indices(nums, target):\n    \"\"\"\n    Alternative: Return pairs with their indices for full traceability.\n    \n    Returns list of ((index1, value1), (index2, value2)) tuples.\n    \"\"\"\n    if len(nums) < 2:\n        return []\n    \n    pairs = []\n    seen = {}  # {number: [list of indices]}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            for j in seen[complement]:\n                pairs.append(((j, complement), (i, num)))\n        \n        if num in seen:\n            seen[num].append(i)\n        else:\n            seen[num] = [i]\n    \n    return pairs\n```\n\n## 3. Complexity Analysis\n\n### Original (Buggy) Version:\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n) | Single pass through array, O(1) dict operations |\n| **Space** | O(n) | Dictionary stores at most n entries |\n\n### Fixed Version (`find_pairs`):\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n + p) where p = number of pairs | For each element, we iterate through all matching complements. Worst case O(n²) when all elements are same and sum to target |\n| **Space** | O(n + p) | Dictionary stores all indices, output stores all pairs |\n\n**Worst Case Example**: `[3,3,3,...,3]` (n times) with target `6`\n- Number of pairs = n*(n-1)/2 = O(n²)\n- Time: O(n²), Space: O(n²)\n\n### Fixed Version (`find_pairs_unique`):\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n) | Single pass, O(1) set operations |\n| **Space** | O(n) | Sets store at most n unique values |\n\n## 4. Comprehensive Test Cases\n\n```python\nimport unittest\n\nclass TestFindPairs(unittest.TestCase):\n    \n    # ==================== Basic Functionality ====================\n    \n    def test_basic_pair(self):\n        \"\"\"Simple case with one pair\"\"\"\n        self.assertEqual(find_pairs([1, 2, 3, 4], 5), [(1, 4), (2, 3)])\n    \n    def test_single_pair(self):\n        \"\"\"List with exactly one pair\"\"\"\n        self.assertEqual(find_pairs([1, 9], 10), [(1, 9)])\n    \n    def test_no_pairs(self):\n        \"\"\"No pairs sum to target\"\"\"\n        self.assertEqual(find_pairs([1, 2, 3], 10), [])\n    \n    # ==================== Edge Cases ====================\n    \n    def test_empty_list(self):\n        \"\"\"Empty list should return empty\"\"\"\n        self.assertEqual(find_pairs([], 5), [])\n    \n    def test_single_element(self):\n        \"\"\"Single element cannot form a pair\"\"\"\n        self.assertEqual(find_pairs([5], 10), [])\n    \n    def test_single_element_half_target(self):\n        \"\"\"Single element that is half of target - no self-pairing\"\"\"\n        self.assertEqual(find_pairs([4], 8), [])\n    \n    def test_two_elements_no_match(self):\n        \"\"\"Two elements that don't sum to target\"\"\"\n        self.assertEqual(find_pairs([1, 2], 10), [])\n    \n    # ==================== Duplicate Numbers ====================\n    \n    def test_duplicates_simple(self):\n        \"\"\"Two same numbers that sum to target\"\"\"\n        self.assertEqual(find_pairs([3, 3], 6), [(3, 3)])\n    \n    def test_duplicates_triple(self):\n        \"\"\"Three same numbers - should find 3 pairs\"\"\"\n        result = find_pairs([3, 3, 3], 6)\n        self.assertEqual(len(result), 3)\n        self.assertTrue(all(pair == (3, 3) for pair in result))\n    \n    def test_duplicates_quadruple(self):\n        \"\"\"Four same numbers - should find 6 pairs (4 choose 2)\"\"\"\n        result = find_pairs([3, 3, 3, 3], 6)\n        self.assertEqual(len(result), 6)\n    \n    def test_duplicates_mixed(self):\n        \"\"\"Duplicates with other numbers\"\"\"\n        result = find_pairs([1, 3, 3, 5], 6)\n        # Pairs: (1,5), (3,3)\n        self.assertEqual(len(result), 2)\n        self.assertIn((1, 5), result)\n        self.assertIn((3, 3), result)\n    \n    def test_multiple_duplicates(self):\n        \"\"\"Multiple duplicate values\"\"\"\n        result = find_pairs([2, 2, 4, 4], 6)\n        # Pairs: (2,4) appears 4 times (2 twos × 2 fours)\n        self.assertEqual(len(result), 4)\n    \n    # ==================== Negative Numbers ====================\n    \n    def test_negative_numbers(self):\n        \"\"\"Pairs with negative numbers\"\"\"\n        self.assertEqual(find_pairs([-1, 2, -3, 4], 1), [(-1, 2), (-3, 4)])\n    \n    def test_negative_target(self):\n        \"\"\"Negative target sum\"\"\"\n        result = find_pairs([-5, -3, 1, 2], -8)\n        self.assertEqual(result, [(-5, -3)])\n    \n    def test_negative_and_positive_pair(self):\n        \"\"\"Negative and positive forming pair\"\"\"\n        result = find_pairs([-3, 3], 0)\n        self.assertEqual(result, [(-3, 3)])\n    \n    def test_all_negative(self):\n        \"\"\"All negative numbers\"\"\"\n        result = find_pairs([-1, -2, -3, -4], -5)\n        self.assertEqual(len(result), 2)  # (-1,-4) and (-2,-3)\n    \n    # ==================== Zero Handling ====================\n    \n    def test_zero_target_with_zeros(self):\n        \"\"\"Zero target with zeros in list\"\"\"\n        result = find_pairs([0, 0, 0], 0)\n        self.assertEqual(len(result), 3)\n    \n    def test_zero_in_pair(self):\n        \"\"\"Zero as part of a pair\"\"\"\n        result = find_pairs([0, 5, -5], 0)\n        self.assertIn((5, -5), result)\n    \n    def test_zero_target_opposites(self):\n        \"\"\"Zero target with opposite numbers\"\"\"\n        result = find_pairs([1, -1, 2, -2], 0)\n        self.assertEqual(len(result), 2)\n    \n    # ==================== Large Numbers ====================\n    \n    def test_large_numbers(self):\n        \"\"\"Very large numbers\"\"\"\n        result = find_pairs([10**9, 10**9, 1], 2 * 10**9)\n        self.assertEqual(result, [(10**9, 10**9)])\n    \n    def test_large_negative(self):\n        \"\"\"Large negative numbers\"\"\"\n        result = find_pairs([-10**9, 10**9], 0)\n        self.assertEqual(result, [(-10**9, 10**9)])\n    \n    # ==================== Order Preservation ====================\n    \n    def test_order_of_pairs(self):\n        \"\"\"Pairs should be in order of discovery\"\"\"\n        result = find_pairs([1, 4, 2, 3], 5)\n        # When we see 4, we find (1,4)\n        # When we see 3, we find (2,3)\n        self.assertEqual(result, [(1, 4), (2, 3)])\n    \n    # ==================== Unique Pairs Version ====================\n    \n    def test_unique_pairs_duplicates(self):\n        \"\"\"Unique pairs should not repeat same value pair\"\"\"\n        result = find_pairs_unique([3, 3, 3], 6)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result, [(3, 3)])\n    \n    def test_unique_pairs_mixed(self):\n        \"\"\"Unique pairs with mixed duplicates\"\"\"\n        result = find_pairs_unique([1, 1, 2, 2, 3, 3], 4)\n        # Unique pairs: (1,3), (2,2)\n        self.assertEqual(len(result), 2)\n    \n    # ==================== With Indices Version ====================\n    \n    def test_with_indices_basic(self):\n        \"\"\"Indices version returns correct indices\"\"\"\n        result = find_pairs_with_indices([1, 2, 3], 4)\n        self.assertEqual(result, [((0, 1), (2, 3))])\n    \n    def test_with_indices_duplicates(self):\n        \"\"\"Indices version with duplicates\"\"\"\n        result = find_pairs_with_indices([3, 3], 6)\n        self.assertEqual(result, [((0, 3), (1, 3))])\n\n\nclass TestFindPairsPerformance(unittest.TestCase):\n    \"\"\"Performance-related tests\"\"\"\n    \n    def test_large_list_no_pairs(self):\n        \"\"\"Large list with no valid pairs\"\"\"\n        nums = list(range(10000))\n        result = find_pairs(nums, -1)\n        self.assertEqual(result, [])\n    \n    def test_large_list_many_pairs(self):\n        \"\"\"Large list with many pairs\"\"\"\n        nums = list(range(1000))\n        target = 999\n        result = find_pairs(nums, target)\n        # Pairs: (0,999), (1,998), ..., (499,500) = 500 pairs\n        self.assertEqual(len(result), 500)\n\n\nif __name__ == '__main__':\n    # Run tests with verbosity\n    unittest.main(verbosity=2)\n```\n\n## Summary\n\n| Issue | Original Behavior | Fixed Behavior |\n|-------|-------------------|----------------|\n| Duplicates `[3,3,3]`, target=6 | Returns 2 pairs | Returns 3 pairs (all combinations) |\n| Empty list | Returns `[]` | Returns `[]` ✓ |\n| Single element | Returns `[]` | Returns `[]` ✓ |\n| Self-pairing `[4]`, target=8 | Returns `[]` | Returns `[]` ✓ |\n| Negative numbers | Works | Works ✓ |\n| Zeros | Works | Works ✓ |\n\nThe key fix is changing `seen` from storing just the last index to storing **all indices** for each value, enabling proper handling of duplicates.",
      "latency_ms": 50216.12733300208,
      "usage": {
        "prompt_tokens": 256,
        "completion_tokens": 3704,
        "total_tokens": 3960
      },
      "timestamp": 1770389243.67295,
      "error": null
    },
    "opus_4_6": {
      "task_id": "code_generation_002",
      "model_key": "opus_4_6",
      "model_id": "anthropic/claude-opus-4.6",
      "response": "\n\n# Bug Analysis and Fix for `find_pairs`\n\n## 1. Identifying ALL Bugs and Edge Cases\n\n### Bug Analysis of the Original Code\n\n```python\ndef find_pairs(nums, target):\n    pairs = []\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            pairs.append((complement, nums[i]))\n        seen[nums[i]] = i  # BUG: Overwrites index, losing track of duplicates\n    return pairs\n```\n\n**Let me trace through the behavior carefully:**\n\n**Bug 1: Duplicate handling — `seen[nums[i]] = i` stores only the *last* index for each value.**\n- For `[3, 3, 3]` with target `6`: The function yields `(3,3)` twice (at indices 1 and 2), which happens to be correct for \"all pairs\" — but the semantics are fragile. If the requirement is *unique pairs*, it over-counts. If the requirement is *all index-pair combinations*, it under-counts (should be 3 pairs: (0,1), (0,2), (1,2)).\n- The dictionary maps value→single index, so we lose information about how many times a value appeared.\n\n**Bug 2: A number paired with itself — `[4]` with target `8`.**\n- When processing index 0: complement = 4, `seen` is empty, so no pair found. Then `seen[4] = 0`. Result: `[]`. This is actually **correct** — a single element can't pair with itself (there's only one copy). However, for `[4, 4]` with target `8`, it correctly finds `(4, 4)`. So this is more of a **specification clarification** than a bug.\n\n**Bug 3: Missing all valid index combinations for duplicates.**\n- For `[3, 3, 3]` target `6`: Valid index pairs are (0,1), (0,2), (1,2) — that's 3 pairs. The function only finds 2 because `seen` only remembers one previous index at a time, and the check `if complement in seen` fires once per subsequent element but doesn't account for *multiple* earlier occurrences.\n\n**Bug 4: No deduplication option.**\n- The function's contract is ambiguous. If we want *unique value pairs*, `[1,1,1,5,5]` with target `6` should return `[(1,5)]` once, but the function returns it multiple times.\n\n**Edge cases that fail or behave unexpectedly:**\n- **Empty list**: Returns `[]` — actually works fine.\n- **Negative numbers**: `[-1, 7]` with target `6` — works fine since arithmetic is correct.\n- **All same elements**: `[3,3,3,3]` target `6` — returns 3 pairs but should return 6 (C(4,2)) if we want all index combinations.\n- **Zero**: `[0, 0]` target `0` — returns `[(0,0)]` once, which is correct for value pairs but misses combinations if multiple zeros exist.\n\n### Summary of Bugs\n\n| # | Bug | Example | Expected | Actual |\n|---|-----|---------|----------|--------|\n| 1 | Overwrites duplicate entries in `seen` dict | `[3,3,3]`, target=6 | 3 index-pairs | 2 pairs |\n| 2 | No distinction between \"all pairs by index\" vs \"unique value pairs\" | `[1,1,5]`, target=6 | Depends on spec | Ambiguous output |\n| 3 | Pair ordering inconsistency | `[5,1]`, target=6 | `(1,5)` or `(5,1)`? | `(1,5)` — complement first |\n\n## 2. Corrected Version\n\nI'll provide **two versions** since the requirements can be interpreted differently:\n\n```python\ndef find_all_pairs_by_index(nums, target):\n    \"\"\"\n    Find ALL pairs of indices (i, j) where i < j and nums[i] + nums[j] == target.\n    Returns list of tuples: ((nums[i], nums[j]), (i, j))\n    \n    Handles:\n    - Duplicates: [3,3,3] target 6 → 3 pairs (all combinations)\n    - Negatives: [-1,7] target 6 → 1 pair\n    - Empty list: [] → []\n    - Single element can't pair with itself: [4] target 8 → []\n    - [4,4] target 8 → 1 pair (two distinct elements)\n    \"\"\"\n    if not nums:\n        return []\n    \n    pairs = []\n    # Map from value → list of all indices where that value appears\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            # Pair current index with ALL previous indices that have the complement value\n            for j in seen[complement]:\n                pairs.append(((complement, num), (j, i)))\n        \n        # Append (not overwrite) the current index to the list for this value\n        if num in seen:\n            seen[num].append(i)\n        else:\n            seen[num] = [i]\n    \n    return pairs\n\n\ndef find_unique_pairs(nums, target):\n    \"\"\"\n    Find all UNIQUE value pairs (a, b) where a + b == target and a <= b.\n    Each unique pair is returned only once regardless of how many times\n    the values appear in the list.\n    \n    Handles:\n    - Duplicates: [3,3,3] target 6 → [(3,3)]\n    - Negatives: [-1,7] target 6 → [(-1,7)]\n    - Empty list: [] → []\n    - Single element: [4] target 8 → [] (need two distinct positions)\n    - [4,4] target 8 → [(4,4)]\n    \"\"\"\n    if not nums:\n        return []\n    \n    pairs = set()\n    seen_counts = {}  # value → count of occurrences seen so far\n    \n    for num in nums:\n        complement = target - num\n        \n        if complement in seen_counts:\n            # For a number pairing with itself, we need at least one prior occurrence\n            # For different numbers, we just need complement to have been seen\n            pair = (min(complement, num), max(complement, num))\n            pairs.add(pair)\n        \n        seen_counts[num] = seen_counts.get(num, 0) + 1\n    \n    return sorted(pairs)\n\n\ndef find_pairs_with_count(nums, target):\n    \"\"\"\n    Find all pairs by index, but return as a clean list of value tuples.\n    [3,3,3] target 6 → [(3,3), (3,3), (3,3)]  (one per valid index pair)\n    \n    This is the most direct \"fix\" of the original function.\n    \"\"\"\n    if not nums:\n        return []\n    \n    pairs = []\n    # Map from value → list of indices\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            for _ in seen[complement]:\n                pairs.append((complement, num))\n        \n        if num in seen:\n            seen[num].append(i)\n        else:\n            seen[num] = [i]\n    \n    return pairs\n```\n\n## 3. Complexity Analysis\n\n### Buggy Version\n\n| Aspect | Complexity | Reasoning |\n|--------|-----------|-----------|\n| **Time** | **O(n)** average | Single pass through array. Dictionary lookup is O(1) average. |\n| **Space** | **O(n)** | Dictionary stores at most n entries. Output list is additional. |\n\nNote: The buggy version is O(n) time precisely *because* it only stores one index per value — which is also why it's incorrect.\n\n### Fixed Versions\n\n**`find_all_pairs_by_index` / `find_pairs_with_count`:**\n\n| Aspect | Complexity | Reasoning |\n|--------|-----------|-----------|\n| **Time** | **O(n + P)** where P = number of output pairs | For each element, we iterate over all previous indices with the complement value. In the worst case (all elements equal, target = 2×element), P = O(n²), so worst case is **O(n²)**. |\n| **Space** | **O(n + P)** | Dictionary stores all n indices across its lists. Output stores P pairs. |\n\n*Worst case example*: `[3,3,3,...,3]` (n times), target=6 → P = C(n,2) = n(n-1)/2 = O(n²).\n\nThis is **unavoidable** — if there are O(n²) valid pairs, any correct algorithm must output all of them, so O(n²) is a lower bound.\n\n**`find_unique_pairs`:**\n\n| Aspect | Complexity | Reasoning |\n|--------|-----------|-----------|\n| **Time** | **O(n log n)** worst case | O(n) for the scan, O(P log P) for sorting output where P ≤ n. Or O(n) if we don't sort. |\n| **Space** | **O(n)** | Counter dict + set of unique pairs (at most n/2 pairs). |\n\n## 4. Comprehensive Test Cases\n\n```python\nimport pytest\n\n\nclass TestFindAllPairsByIndex:\n    \"\"\"Tests for find_all_pairs_by_index — returns ALL index combinations.\"\"\"\n    \n    # === Basic functionality ===\n    \n    def test_simple_pair(self):\n        result = find_all_pairs_by_index([1, 5], 6)\n        assert result == [((1, 5), (0, 1))]\n    \n    def test_multiple_pairs_different_values(self):\n        result = find_all_pairs_by_index([1, 2, 3, 4, 5], 6)\n        values = [pair[0] for pair in result]\n        assert (1, 5) in values\n        assert (2, 4) in values\n        assert (3, 3) not in values  # only one 3, can't pair with itself\n        assert len(result) == 2\n    \n    # === Edge cases ===\n    \n    def test_empty_list(self):\n        assert find_all_pairs_by_index([], 6) == []\n    \n    def test_single_element(self):\n        assert find_all_pairs_by_index([4], 8) == []\n    \n    def test_single_element_not_target(self):\n        assert find_all_pairs_by_index([3], 6) == []\n    \n    def test_no_valid_pairs(self):\n        assert find_all_pairs_by_index([1, 2, 3], 100) == []\n    \n    def test_two_elements_no_match(self):\n        assert find_all_pairs_by_index([1, 2], 6) == []\n    \n    # === Duplicate handling ===\n    \n    def test_two_duplicates(self):\n        result = find_all_pairs_by_index([3, 3], 6)\n        assert len(result) == 1\n        assert result[0] == ((3, 3), (0, 1))\n    \n    def test_three_duplicates(self):\n        result = find_all_pairs_by_index([3, 3, 3], 6)\n        assert len(result) == 3  # C(3,2) = 3 pairs\n        indices = [pair[1] for pair in result]\n        assert (0, 1) in indices\n        assert (0, 2) in indices\n        assert (1, 2) in indices\n    \n    def test_four_duplicates(self):\n        result = find_all_pairs_by_index([3, 3, 3, 3], 6)\n        assert len(result) == 6  # C(4,2) = 6 pairs\n    \n    def test_duplicates_with_other_values(self):\n        result = find_all_pairs_by_index([1, 5, 1, 5], 6)\n        assert len(result) == 4  # (0,1), (0,3), (2,1), (2,3)\n    \n    # === Negative numbers ===\n    \n    def test_negative_and_positive(self):\n        result = find_all_pairs_by_index([-1, 7], 6)\n        assert len(result) == 1\n        assert result[0] == ((-1, 7), (0, 1))\n    \n    def test_two_negatives(self):\n        result = find_all_pairs_by_index([-2, -4], -6)\n        assert len(result) == 1\n        assert result[0] == ((-4, -2), (1, 0)) or result[0] == ((-2, -4), (0, 1))\n        # Let's check: complement of -2 is -6-(-2)=-4, not in seen. \n        # complement of -4 is -6-(-4)=-2, in seen. So pair is (-2, -4), indices (0,1)\n        assert result[0] == ((-2, -4), (0, 1))\n    \n    def test_negative_target(self):\n        result = find_all_pairs_by_index([1, -7], -6)\n        assert len(result) == 1\n    \n    def test_mixed_negatives_positives(self):\n        result = find_all_pairs_by_index([-3, -1, 0, 1, 3, 7], 6)\n        values = [pair[0] for pair in result]\n        assert (-1, 7) in values\n        assert (-3, 9) not in values  # 9 not in list\n        assert (3, 3) not in values   # only one 3\n    \n    # === Zero handling ===\n    \n    def test_zero_target_with_zeros(self):\n        result = find_all_pairs_by_index([0, 0], 0)\n        assert len(result) == 1\n    \n    def test_zero_target_with_negatives(self):\n        result = find_all_pairs_by_index([-3, 3], 0)\n        assert len(result) == 1\n    \n    def test_zero_in_list(self):\n        result = find_all_pairs_by_index([0, 6], 6)\n        assert len(result) == 1\n    \n    # === Large / stress cases ===\n    \n    def test_large_list_no_pairs(self):\n        nums = list(range(1000))\n        result = find_all_pairs_by_index(nums, 2000)\n        assert len(result) == 0\n    \n    def test_large_list_all_same(self):\n        nums = [5] * 100\n        result = find_all_pairs_by_index(nums, 10)\n        expected_count = 100 * 99 // 2  # C(100, 2) = 4950\n        assert len(result) == expected_count\n    \n    # === Self-pairing edge case ===\n    \n    def test_number_cannot_pair_with_itself_single(self):\n        \"\"\"A single 4 cannot form pair (4,4) for target 8.\"\"\"\n        result = find_all_pairs_by_index([4], 8)\n        assert result == []\n    \n    def test_number_pairs_with_duplicate_of_itself(self):\n        \"\"\"Two 4s CAN form pair (4,4) for target 8.\"\"\"\n        result = find_all_pairs_by_index([4, 4], 8)\n        assert len(result) == 1\n    \n    # === Order verification ===\n    \n    def test_indices_are_ordered(self):\n        \"\"\"First index should always be less than second.\"\"\"\n        result = find_all_pairs_by_index([5, 1, 3, 2, 4], 6)\n        for _, (i, j) in result:\n            assert i < j\n\n\nclass TestFindUniquePairs:\n    \"\"\"Tests for find_unique_pairs — returns unique value pairs only.\"\"\"\n    \n    def test_simple(self):\n        assert find_unique_pairs([1, 5, 2, 4], 6) == [(1, 5), (2, 4)]\n    \n    def test",
      "latency_ms": 55621.83925000136,
      "usage": {
        "prompt_tokens": 257,
        "completion_tokens": 4096,
        "total_tokens": 4353
      },
      "timestamp": 1770389249.1176891,
      "error": null
    }
  }
}