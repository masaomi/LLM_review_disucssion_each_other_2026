{
  "task_id": "code_generation_002",
  "models": {
    "opus_4_5": {
      "task_id": "code_generation_002",
      "model_key": "opus_4_5",
      "model_id": "anthropic/claude-opus-4.5",
      "response": "# Analysis of the Buggy `find_pairs` Function\n\n## 1. Identifying ALL Bugs and Edge Cases\n\n### Bugs in the Original Code:\n\n**Bug 1: Incorrect handling of duplicate numbers**\n- The `seen` dictionary only stores one index per number value\n- When duplicates exist (e.g., `[3, 3, 3]` with target `6`), it only finds one pair instead of all valid pairs\n- Each new occurrence overwrites the previous index in `seen`\n\n**Bug 2: Missing pairs with duplicates**\n- For `[3, 3, 3]` with target `6`, there are 3 valid pairs: `(3,3)`, `(3,3)`, `(3,3)` (indices: (0,1), (0,2), (1,2))\n- The current code only finds pairs where the complement was seen *before* the current element\n\n**Bug 3: Self-pairing issue**\n- For `[4]` with target `8`, the number `4` cannot pair with itself (only one instance exists)\n- The current code correctly handles this by checking `seen` before adding current number\n- However, for `[4, 4]` with target `8`, it should find the pair - which it does correctly\n\n### Edge Cases Not Properly Handled:\n\n1. **Empty list**: Returns `[]` - actually works correctly\n2. **Single element**: Works correctly (no self-pairing)\n3. **Multiple duplicates**: Fails to find all pairs\n4. **Negative numbers**: Actually works correctly in the original\n5. **Zero in the list**: Works correctly\n6. **All same numbers**: Fails (subset of duplicate issue)\n\nLet me trace through an example to show the bug:\n\n```python\n# nums = [3, 3, 3], target = 6\n# Expected pairs (by indices): (0,1), (0,2), (1,2) → 3 pairs\n# \n# i=0: complement=3, seen={}, 3 not in seen, seen={3:0}\n# i=1: complement=3, seen={3:0}, 3 in seen → pairs=[(3,3)], seen={3:1}\n# i=2: complement=3, seen={3:1}, 3 in seen → pairs=[(3,3),(3,3)], seen={3:2}\n# \n# Returns 2 pairs, but there are 3 unique index pairs!\n```\n\n## 2. Corrected Version\n\n```python\ndef find_pairs(nums, target):\n    \"\"\"\n    Find all pairs of numbers in a list that sum to a target value.\n    \n    Args:\n        nums: List of numbers (can include duplicates, negatives, zeros)\n        target: Target sum value\n        \n    Returns:\n        List of tuples, where each tuple contains:\n        - The two numbers that sum to target\n        - Optionally: their indices (see variant below)\n        \n    Note: Each pair of indices is counted once. For [3,3,3] with target 6,\n          returns 3 pairs: indices (0,1), (0,2), (1,2)\n    \"\"\"\n    if not nums:  # Handle empty list explicitly\n        return []\n    \n    pairs = []\n    # Store all indices for each number value\n    seen = {}  # {number: [list of indices]}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            # Pair current number with ALL previous occurrences of complement\n            for prev_idx in seen[complement]:\n                pairs.append((complement, num))\n        \n        # Add current index to the list of indices for this number\n        if num not in seen:\n            seen[num] = []\n        seen[num].append(i)\n    \n    return pairs\n\n\ndef find_pairs_with_indices(nums, target):\n    \"\"\"\n    Variant that returns pairs with their indices for clarity.\n    \n    Returns:\n        List of tuples: ((num1, num2), (idx1, idx2))\n    \"\"\"\n    if not nums:\n        return []\n    \n    pairs = []\n    seen = {}  # {number: [list of indices]}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            for prev_idx in seen[complement]:\n                pairs.append(((complement, num), (prev_idx, i)))\n        \n        if num not in seen:\n            seen[num] = []\n        seen[num].append(i)\n    \n    return pairs\n\n\ndef find_unique_pairs(nums, target):\n    \"\"\"\n    Variant that returns only unique value pairs (not counting duplicates).\n    \n    For [3,3,3] with target 6, returns just [(3,3)] once.\n    For [1,2,3,4] with target 5, returns [(1,4), (2,3)]\n    \"\"\"\n    if not nums:\n        return []\n    \n    pairs = set()\n    seen = set()\n    \n    for num in nums:\n        complement = target - num\n        \n        if complement in seen:\n            # Use sorted tuple to avoid (1,4) and (4,1) being different\n            pair = tuple(sorted([complement, num]))\n            pairs.add(pair)\n        \n        seen.add(num)\n    \n    return list(pairs)\n```\n\n## 3. Complexity Analysis\n\n### Original Buggy Version:\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n) | Single pass through the list, O(1) dictionary operations |\n| **Space** | O(n) | Dictionary stores at most n entries (one per unique number) |\n\n### Fixed Version (`find_pairs`):\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n²) worst case | For each element, we might iterate through all previous indices of the complement. Worst case: all elements are the same and equal to target/2 |\n| **Time** | O(n) average case | When duplicates are limited |\n| **Space** | O(n) | Dictionary stores all indices, total n indices across all lists |\n| **Output Space** | O(n²) worst case | Could have n*(n-1)/2 pairs |\n\n### Fixed Version (`find_unique_pairs`):\n\n| Aspect | Complexity | Explanation |\n|--------|------------|-------------|\n| **Time** | O(n) | Single pass, O(1) set operations |\n| **Space** | O(n) | Set stores at most n unique numbers |\n\n## 4. Comprehensive Test Cases\n\n```python\nimport unittest\n\nclass TestFindPairs(unittest.TestCase):\n    \"\"\"Comprehensive test suite for find_pairs function.\"\"\"\n    \n    # ==================== Basic Functionality ====================\n    \n    def test_basic_pair(self):\n        \"\"\"Simple case with one valid pair.\"\"\"\n        self.assertEqual(find_pairs([1, 2, 3, 4], 5), [(1, 4), (2, 3)])\n    \n    def test_no_pairs(self):\n        \"\"\"No pairs sum to target.\"\"\"\n        self.assertEqual(find_pairs([1, 2, 3], 10), [])\n    \n    def test_single_pair(self):\n        \"\"\"Exactly one pair exists.\"\"\"\n        self.assertEqual(find_pairs([1, 9], 10), [(1, 9)])\n    \n    # ==================== Edge Cases ====================\n    \n    def test_empty_list(self):\n        \"\"\"Empty list should return empty result.\"\"\"\n        self.assertEqual(find_pairs([], 5), [])\n    \n    def test_single_element(self):\n        \"\"\"Single element cannot pair with itself.\"\"\"\n        self.assertEqual(find_pairs([4], 8), [])\n    \n    def test_two_elements_no_match(self):\n        \"\"\"Two elements that don't sum to target.\"\"\"\n        self.assertEqual(find_pairs([1, 2], 10), [])\n    \n    def test_two_elements_match(self):\n        \"\"\"Two elements that sum to target.\"\"\"\n        self.assertEqual(find_pairs([3, 7], 10), [(3, 7)])\n    \n    # ==================== Duplicate Numbers ====================\n    \n    def test_two_same_numbers(self):\n        \"\"\"Two identical numbers summing to target.\"\"\"\n        self.assertEqual(find_pairs([4, 4], 8), [(4, 4)])\n    \n    def test_three_same_numbers(self):\n        \"\"\"Three identical numbers - should find 3 pairs.\"\"\"\n        result = find_pairs([3, 3, 3], 6)\n        self.assertEqual(len(result), 3)\n        self.assertTrue(all(pair == (3, 3) for pair in result))\n    \n    def test_four_same_numbers(self):\n        \"\"\"Four identical numbers - should find 6 pairs (4 choose 2).\"\"\"\n        result = find_pairs([2, 2, 2, 2], 4)\n        self.assertEqual(len(result), 6)\n    \n    def test_duplicates_with_different_numbers(self):\n        \"\"\"Mix of duplicates and different numbers.\"\"\"\n        result = find_pairs([1, 1, 2, 2], 3)\n        # Pairs: (1@0, 2@2), (1@0, 2@3), (1@1, 2@2), (1@1, 2@3) = 4 pairs\n        self.assertEqual(len(result), 4)\n        self.assertTrue(all(pair == (1, 2) for pair in result))\n    \n    # ==================== Negative Numbers ====================\n    \n    def test_negative_numbers(self):\n        \"\"\"Pairs involving negative numbers.\"\"\"\n        self.assertEqual(find_pairs([-1, 2, 3], 2), [(-1, 3)])\n    \n    def test_two_negatives(self):\n        \"\"\"Two negative numbers summing to negative target.\"\"\"\n        self.assertEqual(find_pairs([-3, -7, 1], -10), [(-3, -7)])\n    \n    def test_negative_and_positive_to_zero(self):\n        \"\"\"Negative and positive summing to zero.\"\"\"\n        self.assertEqual(find_pairs([-5, 5, 3], 0), [(-5, 5)])\n    \n    def test_all_negative(self):\n        \"\"\"All negative numbers.\"\"\"\n        result = find_pairs([-1, -2, -3, -4], -5)\n        self.assertEqual(sorted(result), sorted([(-1, -4), (-2, -3)]))\n    \n    # ==================== Zero Handling ====================\n    \n    def test_zeros_summing_to_zero(self):\n        \"\"\"Two zeros summing to zero.\"\"\"\n        self.assertEqual(find_pairs([0, 0], 0), [(0, 0)])\n    \n    def test_multiple_zeros(self):\n        \"\"\"Multiple zeros - should find all pairs.\"\"\"\n        result = find_pairs([0, 0, 0], 0)\n        self.assertEqual(len(result), 3)\n    \n    def test_zero_with_target(self):\n        \"\"\"Zero paired with target value.\"\"\"\n        self.assertEqual(find_pairs([0, 5, 3], 5), [(0, 5)])\n    \n    # ==================== Large Numbers ====================\n    \n    def test_large_numbers(self):\n        \"\"\"Very large numbers.\"\"\"\n        self.assertEqual(\n            find_pairs([10**9, 10**9, 1], 2 * 10**9),\n            [(10**9, 10**9)]\n        )\n    \n    def test_large_negative_numbers(self):\n        \"\"\"Very large negative numbers.\"\"\"\n        self.assertEqual(\n            find_pairs([-10**9, 10**9], 0),\n            [(-10**9, 10**9)]\n        )\n    \n    # ==================== Order Preservation ====================\n    \n    def test_pair_order(self):\n        \"\"\"Pairs should be (earlier_element, later_element).\"\"\"\n        result = find_pairs([4, 1], 5)\n        self.assertEqual(result, [(4, 1)])  # 4 comes first in list\n    \n    # ==================== Complex Cases ====================\n    \n    def test_multiple_pairs_different_values(self):\n        \"\"\"Multiple pairs with different value combinations.\"\"\"\n        result = find_pairs([1, 2, 3, 4, 5, 6], 7)\n        expected = [(1, 6), (2, 5), (3, 4)]\n        self.assertEqual(result, expected)\n    \n    def test_same_number_different_complements(self):\n        \"\"\"Same number could pair with different complements.\"\"\"\n        result = find_pairs([1, 4, 3, 2], 5)\n        self.assertEqual(sorted(result), sorted([(1, 4), (3, 2)]))\n    \n    # ==================== Float Numbers (Bonus) ====================\n    \n    def test_float_numbers(self):\n        \"\"\"Floating point numbers.\"\"\"\n        result = find_pairs([1.5, 2.5, 3.0], 4.0)\n        self.assertEqual(result, [(1.5, 2.5)])\n\n\nclass TestFindPairsWithIndices(unittest.TestCase):\n    \"\"\"Test the variant that returns indices.\"\"\"\n    \n    def test_returns_correct_indices(self):\n        \"\"\"Verify correct indices are returned.\"\"\"\n        result = find_pairs_with_indices([1, 2, 3, 4], 5)\n        expected = [((1, 4), (0, 3)), ((2, 3), (1, 2))]\n        self.assertEqual(result, expected)\n    \n    def test_duplicate_indices(self):\n        \"\"\"Verify indices for duplicates.\"\"\"\n        result = find_pairs_with_indices([3, 3, 3], 6)\n        expected_indices = [(0, 1), (0, 2), (1, 2)]\n        actual_indices = [idx_pair for _, idx_pair in result]\n        self.assertEqual(actual_indices, expected_indices)\n\n\nclass TestFindUniquePairs(unittest.TestCase):\n    \"\"\"Test the unique pairs variant.\"\"\"\n    \n    def test_duplicates_return_single_pair(self):\n        \"\"\"Multiple same pairs should return just one.\"\"\"\n        result = find_unique_pairs([3, 3, 3], 6)\n        self.assertEqual(result, [(3, 3)])\n    \n    def test_multiple_unique_pairs(self):\n        \"\"\"Multiple different pairs.\"\"\"\n        result = find_unique_pairs([1, 2, 3, 4], 5)\n        self.assertEqual(sorted(result), [(1, 4), (2, 3)])\n\n\n# ==================== Performance Test ====================\n\ndef test_performance():\n    \"\"\"Test with large input to verify reasonable performance.\"\"\"\n    import time\n    \n    # Test with 10,000 elements\n    large_list = list(range(10000))\n    target = 9999\n    \n    start = time.time()\n    result = find_pairs(large_list, target)\n    elapsed = time.time() - start\n    \n    print(f\"Time for 10,000 elements: {elapsed:.4f} seconds\")\n    print(f\"Found {len(result)} pairs\")\n    assert elapsed < 1.0, \"Performance too slow!\"\n    \n    # Worst case: all same numbers\n    same_numbers = [5] * 1000\n    start = time.time()\n    result = find_pairs(same_numbers, 10)\n    elapsed = time.time() - start\n    \n    print(f\"Worst case (1000 same numbers): {elapsed:.4f} seconds\")\n    print(f\"Found {len(result)} pairs (expected {1000*999//2})\")\n\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n    test_performance()\n```\n\n## Summary\n\n| Issue | Original Behavior | Fixed Behavior |\n|-------|-------------------|----------------|\n| Duplicates `[3,3,3]` target=6 | Returns 2 pairs | Returns 3 pairs |\n| Empty list | Returns `[]` ✓ | Returns `[]` ✓ |\n| Single element self-pair | Correctly returns `[]` ✓ | Returns `[]` ✓ |\n| Negative numbers | Works correctly ✓ | Works correctly ✓ |\n| Zeros | Works correctly ✓ | Works correctly ✓ |\n\nThe key fix is storing **all indices** for each number value, allowing us to find all valid pairs when duplicates exist.",
      "latency_ms": 47543.51937499814,
      "usage": {
        "prompt_tokens": 256,
        "completion_tokens": 4078,
        "total_tokens": 4334
      },
      "timestamp": 1770394633.1006799,
      "error": null
    },
    "opus_4_6": {
      "task_id": "code_generation_002",
      "model_key": "opus_4_6",
      "model_id": "anthropic/claude-opus-4.6",
      "response": "\n\n# Bug Analysis and Corrected Implementation\n\n## 1. Identifying ALL Bugs and Edge Cases\n\n### Bugs in the Original Code\n\n**Bug 1: Duplicate pairs are generated when duplicate numbers exist.**\nFor `nums = [3, 3, 3]` with `target = 6`, the dictionary `seen` maps each value to its *last seen index*. As we iterate:\n- `i=0`: complement=3, not in seen → `seen = {3: 0}`\n- `i=1`: complement=3, **is** in seen → appends `(3, 3)`, `seen = {3: 1}`\n- `i=2`: complement=3, **is** in seen → appends `(3, 3)` again, `seen = {3: 2}`\n\nResult: `[(3,3), (3,3)]`. Whether this is a \"bug\" depends on requirements. If we want **unique pairs**, this is wrong. If we want **all index-distinct pairs**, it's *also* wrong — there are actually 3 index-distinct pairs: `(0,1)`, `(0,2)`, `(1,2)`, but we only get 2.\n\n**Bug 2: The `seen` dictionary overwrites duplicate values.**\n`seen[nums[i]] = i` stores only the *latest* index for each value, losing track of all previous occurrences. This means we can't correctly enumerate all pairs when duplicates exist.\n\n**Bug 3: A number can never pair with \"itself\" (same index) — but this is actually CORRECT behavior.**\nFor `[4]` with `target = 8`, the number 4 appears once. It should NOT pair with itself since there's only one element. The original code handles this correctly because `4` isn't in `seen` when we first encounter it. However, the problem statement asks us to handle this case explicitly, so we need to be clear about the semantics.\n\n**Bug 4: No deduplication of equivalent pairs.**\n`(a, b)` and `(b, a)` are logically the same pair. The function may produce both orderings across different inputs.\n\n### Edge Cases That Fail or Need Attention\n\n| Edge Case | Input | Expected | Actual (Buggy) |\n|---|---|---|---|\n| Empty list | `[], 5` | `[]` | `[]` ✓ (works by accident) |\n| Single element | `[4], 8` | `[]` | `[]` ✓ (works correctly) |\n| Duplicates | `[3,3,3], 6` | 3 pairs (by index) or 1 unique pair | 2 pairs (wrong either way) |\n| Negative numbers | `[-1,3], 2` | `[(-1,3)]` | `[(-1,3)]` ✓ (works) |\n| Zero target | `[0,0], 0` | `[(0,0)]` | `[(0,0)]` ✓ (works) |\n| Same value, target double | `[5,5], 10` | `[(5,5)]` | `[(5,5)]` ✓ (works) |\n| Large duplicates | `[1,1,1,1], 2` | 6 index-pairs or 1 unique | 3 (wrong either way) |\n| No valid pairs | `[1,2,3], 10` | `[]` | `[]` ✓ |\n\n## 2. Corrected Versions\n\nI'll provide two versions since \"find all pairs\" is ambiguous:\n\n### Version A: Find All Unique Pairs (by value)\n\n```python\ndef find_unique_pairs(nums, target):\n    \"\"\"\n    Find all unique pairs (by value) that sum to target.\n    Each pair is returned as a sorted tuple to avoid (a,b)/(b,a) duplicates.\n    \n    Handles: duplicates, negatives, empty lists, self-pairing semantics.\n    \n    A pair (v, v) is only included if v appears at least twice in nums.\n    \"\"\"\n    from collections import Counter\n    \n    pairs = []\n    count = Counter(nums)\n    \n    # Track which pairs we've already added to avoid duplicates\n    seen = set()\n    \n    for num in count:\n        complement = target - num\n        \n        # Normalize the pair so smaller value comes first\n        pair = (min(num, complement), max(num, complement))\n        \n        if pair in seen:\n            continue\n        \n        if complement == num:\n            # Need at least 2 occurrences of this number\n            if count[num] >= 2:\n                pairs.append(pair)\n                seen.add(pair)\n        else:\n            # Need at least 1 occurrence of each\n            if complement in count:\n                pairs.append(pair)\n                seen.add(pair)\n    \n    return pairs\n```\n\n### Version B: Find All Index-Distinct Pairs\n\n```python\ndef find_all_index_pairs(nums, target):\n    \"\"\"\n    Find ALL pairs of indices (i, j) where i < j and nums[i] + nums[j] == target.\n    \n    Returns list of tuples: ((nums[i], nums[j]), (i, j))\n    \n    Handles: duplicates, negatives, empty lists.\n    A single element cannot pair with itself (requires two distinct indices).\n    \"\"\"\n    from collections import defaultdict\n    \n    pairs = []\n    # Map each value to ALL indices where it appears\n    value_to_indices = defaultdict(list)\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        # Check all previously-seen indices of the complement\n        if complement in value_to_indices:\n            for j in value_to_indices[complement]:\n                pairs.append(((nums[j], num), (j, i)))\n        \n        value_to_indices[num].append(i)\n    \n    return pairs\n```\n\n### Version C: Clean General-Purpose Version (Recommended)\n\n```python\ndef find_pairs(nums, target):\n    \"\"\"\n    Find all unique pairs of values from nums that sum to target.\n    \n    - Returns pairs as sorted tuples (smaller, larger) with no duplicates.\n    - A value can pair with itself only if it appears more than once.\n    - Handles empty lists, negatives, zeros, and duplicates correctly.\n    \n    Time:  O(n)\n    Space: O(n)\n    \"\"\"\n    from collections import Counter\n    \n    count = Counter(nums)\n    pairs = set()\n    \n    for num in count:\n        complement = target - num\n        \n        if complement == num:\n            if count[num] >= 2:\n                pairs.add((num, num))  # num == complement, so already \"sorted\"\n        elif complement in count:\n            # Normalize pair ordering\n            pairs.add((min(num, complement), max(num, complement)))\n    \n    return sorted(pairs)\n```\n\n## 3. Complexity Analysis\n\n### Buggy Version\n\n| Aspect | Complexity | Reasoning |\n|---|---|---|\n| **Time** | O(n) | Single pass through `nums`; dict lookup is O(1) average |\n| **Space** | O(n) | `seen` dict stores up to n entries; `pairs` stores up to n/2 |\n\n### Fixed Version A (Unique Pairs)\n\n| Aspect | Complexity | Reasoning |\n|---|---|---|\n| **Time** | O(n) | O(n) to build Counter + O(k) to iterate unique keys where k ≤ n |\n| **Space** | O(n) | Counter stores up to n distinct values; pairs set stores up to n/2 |\n\n### Fixed Version B (All Index Pairs)\n\n| Aspect | Complexity | Reasoning |\n|---|---|---|\n| **Time** | O(n²) worst case | If all elements are the same and pair up, e.g., `[3,3,3,...,3]` target=6 → C(n,2) = O(n²) pairs |\n| **Space** | O(n² ) worst case | Output can contain O(n²) pairs; `value_to_indices` stores n entries |\n\n### Fixed Version C (Recommended)\n\n| Aspect | Complexity | Reasoning |\n|---|---|---|\n| **Time** | O(n) | Counter construction O(n) + iteration over unique values O(k), k ≤ n. Sorting output is O(k log k) where k = number of unique pairs, dominated by O(n) |\n| **Space** | O(n) | Counter + pairs set |\n\n## 4. Comprehensive Test Cases\n\n```python\nimport pytest\nfrom collections import Counter\n\n\ndef find_pairs(nums, target):\n    \"\"\"Version C from above.\"\"\"\n    count = Counter(nums)\n    pairs = set()\n    \n    for num in count:\n        complement = target - num\n        if complement == num:\n            if count[num] >= 2:\n                pairs.add((num, num))\n        elif complement in count:\n            pairs.add((min(num, complement), max(num, complement)))\n    \n    return sorted(pairs)\n\n\n# ─── Basic Functionality ───\n\nclass TestBasicFunctionality:\n    def test_simple_pair(self):\n        assert find_pairs([1, 2, 3, 4], 5) == [(1, 4), (2, 3)]\n    \n    def test_single_pair(self):\n        assert find_pairs([1, 9], 10) == [(1, 9)]\n    \n    def test_no_pairs(self):\n        assert find_pairs([1, 2, 3], 10) == []\n    \n    def test_multiple_pairs(self):\n        result = find_pairs([1, 2, 3, 4, 5, 6], 7)\n        assert result == [(1, 6), (2, 5), (3, 4)]\n\n\n# ─── Edge Cases: Empty and Single Element ───\n\nclass TestEdgeCases:\n    def test_empty_list(self):\n        assert find_pairs([], 5) == []\n    \n    def test_single_element_no_pair(self):\n        \"\"\"A single element cannot pair with itself.\"\"\"\n        assert find_pairs([4], 8) == []\n    \n    def test_single_element_nonmatching(self):\n        assert find_pairs([3], 8) == []\n    \n    def test_two_elements_matching(self):\n        assert find_pairs([3, 5], 8) == [(3, 5)]\n    \n    def test_two_elements_not_matching(self):\n        assert find_pairs([3, 6], 8) == []\n\n\n# ─── Duplicate Numbers ───\n\nclass TestDuplicates:\n    def test_two_duplicates_forming_pair(self):\n        \"\"\"[3, 3] with target 6 → one unique pair (3, 3).\"\"\"\n        assert find_pairs([3, 3], 6) == [(3, 3)]\n    \n    def test_three_duplicates_forming_pair(self):\n        \"\"\"[3, 3, 3] with target 6 → still one UNIQUE pair (3, 3).\"\"\"\n        assert find_pairs([3, 3, 3], 6) == [(3, 3)]\n    \n    def test_many_duplicates(self):\n        \"\"\"[1, 1, 1, 1] with target 2 → one unique pair (1, 1).\"\"\"\n        assert find_pairs([1, 1, 1, 1], 2) == [(1, 1)]\n    \n    def test_duplicates_with_different_pairs(self):\n        \"\"\"[1, 1, 2, 3] with target 4 → pairs: (1,3)\"\"\"\n        assert find_pairs([1, 1, 2, 3], 4) == [(1, 3)]\n    \n    def test_duplicates_not_enough_for_self_pair(self):\n        \"\"\"[5] with target 10 → need two 5s but only have one.\"\"\"\n        assert find_pairs([5], 10) == []\n    \n    def test_all_same_no_pair(self):\n        \"\"\"[2, 2, 2] with target 5 → no pairs.\"\"\"\n        assert find_pairs([2, 2, 2], 5) == []\n\n\n# ─── Negative Numbers ───\n\nclass TestNegativeNumbers:\n    def test_negative_and_positive(self):\n        assert find_pairs([-1, 3], 2) == [(-1, 3)]\n    \n    def test_two_negatives(self):\n        assert find_pairs([-3, -2, -1], -5) == [(-3, -2)]\n    \n    def test_negative_with_zero(self):\n        assert find_pairs([-5, 0, 5], 0) == [(-5, 5)]\n    \n    def test_all_negatives_multiple_pairs(self):\n        result = find_pairs([-4, -3, -2, -1], -5)\n        assert result == [(-4, -1), (-3, -2)]\n    \n    def test_mixed_signs(self):\n        result = find_pairs([-2, -1, 0, 1, 2, 3], 1)\n        assert result == [(-2, 3), (-1, 2), (0, 1)]\n\n\n# ─── Zero Handling ───\n\nclass TestZeros:\n    def test_zero_pair(self):\n        \"\"\"Two zeros sum to zero.\"\"\"\n        assert find_pairs([0, 0], 0) == [(0, 0)]\n    \n    def test_single_zero(self):\n        \"\"\"One zero can't pair with itself.\"\"\"\n        assert find_pairs([0], 0) == []\n    \n    def test_zero_with_target_nonzero(self):\n        assert find_pairs([0, 5], 5) == [(0, 5)]\n    \n    def test_multiple_zeros(self):\n        assert find_pairs([0, 0, 0], 0) == [(0, 0)]\n\n\n# ─── Large Numbers and Overflow ───\n\nclass TestLargeNumbers:\n    def test_large_values(self):\n        assert find_pairs([10**18, -(10**18)], 0) == [(-10**18, 10**18)]\n    \n    def test_large_target(self):\n        assert find_pairs([10**9, 10**9 + 1], 2 * 10**9 + 1) == [(10**9, 10**9 + 1)]\n\n\n# ─── Return Format and Ordering ───\n\nclass TestReturnFormat:\n    def test_pairs_are_sorted_tuples(self):\n        \"\"\"Each pair should have smaller element first.\"\"\"\n        result = find_pairs([5, 1], 6)\n        assert result == [(1, 5)]\n        for pair in result:\n            assert pair[0] <= pair[1]\n    \n    def test_result_is_sorted(self):\n        result = find_pairs([6, 1, 5, 2, 4, 3], 7)\n        assert result == sorted(result)\n    \n    def test_no_duplicate_pairs_in_output(self):\n        result = find_pairs([1, 1, 2, 2, 3, 3], 4)\n        assert len(result) == len(set(result)), \"Duplicate pairs found in output\"\n        assert result == [(1, 3), (2, 2)]\n\n\n# ─── Stress / Property-Based Sanity ───\n\nclass TestProperties:\n    def test_all_pairs_sum_to_target(self):\n        \"\"\"Every returned pair must actually sum to the target.\"\"\"\n        nums = [1, 2, 3, 4, 5, -1, -2, 0, 3, 3]\n        target = 6\n        result = find_pairs(nums, target)\n        for a, b in result:\n            assert a + b == target, f\"Pair ({a}, {b}) does not sum to {target}\"\n    \n    def test_all_values_exist_in_input(self):\n        \"\"\"Every value in a pair must exist in the input list.\"\"\"\n        nums = [1, 2, 3, 4, 5]\n        target = 6\n        count = Counter(nums)\n        result = find_pairs(nums, target)\n        for a, b in result:\n            if a == b:\n                assert count[a] >= 2, f\"Need at least 2 of {a} but have {count[a]}\"\n            else:\n                assert a in count, f\"{a} not in input\"\n                assert b in count, f\"{b} not",
      "latency_ms": 57358.469792001415,
      "usage": {
        "prompt_tokens": 257,
        "completion_tokens": 4096,
        "total_tokens": 4353
      },
      "timestamp": 1770394642.943646,
      "error": null
    },
    "gemini_3_pro": {
      "task_id": "code_generation_002",
      "model_key": "gemini_3_pro",
      "model_id": "google/gemini-3-pro-preview",
      "response": "Here is a comprehensive analysis of the provided function, the identified bugs, a corrected solution, complexity analysis, and test cases.\n\n### 1. Identify ALL bugs and edge cases\n\nThe original function `find_pairs` attempts to solve the \"Two Sum\" problem (finding pairs that sum to a target) but fails in specific scenarios due to how it tracks visited numbers.\n\n**The Major Bugs:**\n\n1.  **Missing Combinations (The Overwriting Bug):**\n    The function uses a dictionary `seen` where `seen[nums[i]] = i`. If a number appears multiple times in the list, the dictionary key is overwritten with the *newest* index.\n    *   *Scenario:* Input `[3, 3, 3]` with `target = 6`.\n    *   *Expected:* 3 pairs (Index 0+1, Index 0+2, Index 1+2).\n    *   *Actual:* The function returns 2 pairs. It fails to account for the fact that the current number can form a pair with *all* previous instances of the complement, not just the most recent one.\n\n2.  **Duplicate Output Logic (Ambiguity):**\n    While not a runtime error, the function returns pairs as `(complement, current)`. If the input is `[1, 2]` with target `3`, it returns",
      "latency_ms": 43988.889042000665,
      "usage": {
        "prompt_tokens": 241,
        "completion_tokens": 4092,
        "total_tokens": 4333
      },
      "timestamp": 1770394629.5939252,
      "error": null
    }
  }
}